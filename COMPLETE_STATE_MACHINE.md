# LWM Window Manager - Complete Logic Specification

> **⚠️⚠️ SUPERSEDED DOCUMENT - DO NOT USE FOR NEW WORK ⚠️⚠️**
>
> This document has been **replaced by focused documents** for improved navigability and maintainability.
>
> **Use these documents instead:**
> - **[DOCS_INDEX.md](DOCS_INDEX.md)** - Complete documentation roadmap
> - **[IMPLEMENTATION.md](IMPLEMENTATION.md)** - Architecture, data structures, invariants
> - **[STATE_MACHINE.md](STATE_MACHINE.md)** - Window states, state transitions, lifecycle
> - **[EVENT_HANDLING.md](EVENT_HANDLING.md)** - Event-by-event handling specifications
> - **[BEHAVIOR.md](BEHAVIOR.md)** - User-facing behavior
> - **[COMPLIANCE.md](COMPLIANCE.md)** - Protocol obligations
>
> **Status:** Retained for historical reference during transition period. Content here may be outdated.

> **Documentation Navigation**
> - Previous: [BEHAVIOR.md](BEHAVIOR.md) (User-facing behavior) | [CLAUDE.md](CLAUDE.md) (Development guide)
> - Related: [COMPLIANCE.md](COMPLIANCE.md) (Protocol requirements) | [SPEC_CLARIFICATIONS.md](SPEC_CLARIFICATIONS.md) (Design decisions)

**Legacy Content Below** - This document is the **authoritative implementation specification** for LWM. It defines the complete state machine, data structures, invariants, and event handling logic that the window manager implements.

**Scope**:
- Exact implementation details not covered in higher-level docs
- Complete state transitions and edge cases
- Data structure relationships and invariants
- Event-by-event handling specifications
- Configuration system and window rules engine

**Complementary documents**:
- [BEHAVIOR.md](BEHAVIOR.md) - User-visible behavior (focus, workspaces, monitors)
- [CLAUDE.md](CLAUDE.md) - Quick reference for contributors (architecture, code style)
- [COMPLIANCE.md](COMPLIANCE.md) - Protocol obligations (ICCCM/EWMH)
- [SPEC_CLARIFICATIONS.md](SPEC_CLARIFICATIONS.md) - Design decisions on spec ambiguities

## Table of Contents
1. [Architecture Overview](#architecture-overview)
2. [Data Structures](#data-structures)
3. [Terminology](#terminology)
4. [Invariants](#invariants)
5. [Error Handling and Validation](#error-handling-and-validation)
6. [Window State Machine](#window-state-machine)
7. [Event Loop](#event-loop)
8. [Focus System](#focus-system)
9. [Workspace Management](#workspace-management)
10. [Monitor Behavior](#monitor-behavior)
11. [Interaction Modes](#interaction-modes)
12. [Geometry Management](#geometry-management)
13. [Layout Algorithm](#layout-algorithm)
14. [Floating Windows](#floating-windows)
15. [Drag Operations](#drag-operations)
16. [EWMH Protocol](#ewmh-protocol)
17. [ICCCM Compliance](#icccm-compliance)
18. [Configuration](#configuration)
19. [Special Cases](#special-cases)

---

## Architecture Overview

### Core Components

```
WindowManager (wm.cpp)
├── clients_ (unordered_map<window, Client>)  ← Authoritative state
├── monitors_ (vector<Monitor>)
├── floating_windows_ (vector<FloatingWindow>)
├── dock_windows_ (vector<window>)
├── desktop_windows_ (vector<window>)
└── Ewmh, KeybindManager, Layout
```

### Entry Points

**main()** → WindowManager construction → run() → Main event loop

**Initialization Sequence:**
1. setup_signal_handlers()
2. init_mousebinds()
3. create_wm_window()
4. setup_root() (SubstructureRedirect)
5. grab_buttons()
6. claim_wm_ownership() (WM_S0 selection)
7. intern_atoms()
8. window_rules_.load_rules()
9. layout_.set_sync_request_callback()
10. detect_monitors()
11. setup_ewmh()
12. scan_existing_windows()
13. run_autostart()
14. keybinds_.grab_keys()
15. update_ewmh_client_list()

---

## Terminology

**Synthetic event**: Generated by X server or window manager rather than natural X11 events. Example: synthetic ConfigureNotify sent by WM to inform client of geometry after layout changes.

**Intentional no-op**: Graceful early return with no error logging for invalid state or unsupported operations.

**Best-effort**: Reflects known-good state when set, but may become stale if underlying state changes. Callers must validate before use.

**MRU (Most Recently Used)**: Reverse iteration through vectors (newest items at end) provides MRU ordering for focus restoration and floating window stacking.

---

## Data Structures

### Client (src/lwm/core/types.hpp)

Authoritative source of truth for all window state.

```cpp
struct Client {
    xcb_window_t id = XCB_NONE;
    enum class Kind { Tiled, Floating, Dock, Desktop };
    Kind kind = Kind::Tiled;
    size_t monitor = 0;
    size_t workspace = 0;
    std::string name;
    std::string wm_class;
    std::string wm_class_name;

    // State flags (synced with _NET_WM_STATE)
    bool hidden = false;              // True when window is moved off-screen by WM
    bool fullscreen = false;
    bool above = false;
    bool below = false;
    bool iconic = false;
    bool sticky = false;
    bool maximized_horz = false;
    bool maximized_vert = false;
    bool shaded = false;
    bool modal = false;
    bool skip_taskbar = false;
    bool skip_pager = false;
    bool demands_attention = false;

    // Floating-specific
    Geometry floating_geometry;
    xcb_window_t transient_for = XCB_NONE;

    // Restore points
    std::optional<Geometry> fullscreen_restore;
    std::optional<Geometry> maximize_restore;
    std::optional<FullscreenMonitors> fullscreen_monitors;

    // Sync protocol
    uint32_t sync_counter = 0;
    uint64_t sync_value = 0;

    // Focus stealing prevention
    uint32_t user_time = 0;
    xcb_window_t user_time_window = XCB_NONE;

    // Management tracking
    uint64_t order = 0;              // Unique monotonically increasing value
};

**WindowManager class members**:
- `next_client_order_`: Counter for generating unique, monotonically increasing Client.order values
  - Incremented when each new window is managed
  - Used for consistent _NET_CLIENT_LIST ordering
```

### Workspace

```cpp
struct Workspace {
    std::vector<xcb_window_t> windows;  // Tiling order
    xcb_window_t focused_window = XCB_NONE;
};
```

### Monitor

```cpp
struct Monitor {
    xcb_randr_output_t output;
    std::string name;
    int16_t x, y;
    uint16_t width, height;
    std::vector<Workspace> workspaces;
    size_t current_workspace = 0;
    size_t previous_workspace = 0;
    Strut strut;
};
```

### FloatingWindow

```cpp
struct FloatingWindow {
    xcb_window_t id = XCB_NONE;
    Geometry geometry;  // Runtime geometry only
};
```

### DragState

```cpp
struct DragState {
    bool active = false;
    bool resizing = false;
    bool tiled = false;
    xcb_window_t window = XCB_NONE;
    int16_t start_root_x, start_root_y;
    int16_t last_root_x, last_root_y;
    Geometry start_geometry;
};
```

### Geometry Types

```cpp
struct Geometry {
    int16_t x = 0;
    int16_t y = 0;
    uint16_t width = 0;
    uint16_t height = 0;
};

struct Strut {
    uint32_t left, right, top, bottom;
};

struct FullscreenMonitors {
    uint32_t top, bottom, left, right;
};
```

**Strut Aggregation**:
- Multiple dock windows can coexist on same monitor
- Struts aggregated by taking maximum value for each side
- Example: If dock A has top=30 and dock B has top=50, effective top strut is 50
- Ensures all dock reservations honored simultaneously

### Key Constants

```cpp
constexpr int16_t OFF_SCREEN_X = -20000;
constexpr auto SYNC_WAIT_TIMEOUT = std::chrono::milliseconds(50);  // Sync request timeout
constexpr auto PING_TIMEOUT = std::chrono::seconds(5);            // Ping response window
constexpr auto KILL_TIMEOUT = std::chrono::seconds(5);             // Force-kill timeout

// WM_STATE values
constexpr uint32_t WM_STATE_WITHDRAWN = 0;
constexpr uint32_t WM_STATE_NORMAL = 1;
constexpr uint32_t WM_STATE_ICONIC = 3;
```

---

## Invariants

### Runtime Invariant Check Status

Invariant checks (LWM_ASSERT_INVARIANTS, LWM_ASSERT_CLIENT_STATE, LWM_ASSERT_FOCUS_CONSISTENCY) are defined in debug builds but never invoked in the current implementation.

### Single Source of Truth

**Client struct is authoritative for all window state.**
- FloatingWindow.geometry is transient (runtime state)
- Workspace vectors are derived (organization state)
- All other structures reference `clients_`

### Data Structure Relationships

**Monitor → Workspace containment:**
- Each Monitor contains a vector of Workspace objects
- Monitors track current_workspace and previous_workspace indices
- Workspaces belong to exactly one monitor

**Window containment (one-to-many):**
- Each window appears in exactly one container based on kind:
  - Kind::Tiled → Appears in exactly one Workspace::windows vector
  - Kind::Floating → Appears in exactly one floating_windows_ entry
  - Kind::Dock → Appears in exactly one dock_windows_ entry
  - Kind::Desktop → Appears in exactly one desktop_windows_ entry
- All managed windows appear in clients_ registry (unified source of truth)

**Cross-references:**
- FloatingWindow.geometry ↔ Client.floating_geometry (synchronized via apply_floating_geometry())
- Workspace.focused_window references a window ID (best-effort hint)

### State Synchronization Guarantees

1. **Client ↔ EWMH**: Every state flag change updates EWMH property
2. **Client ↔ ICCCM**: WM_STATE property tracks iconic state
3. **FloatingWindow ↔ Client**: Geometry synced on all operations
4. **Workspace ↔ Focus**: `workspace.focused_window` tracks last-focused (best-effort)
5. **Global State**: All visible state has EWMH root property

### Client Management Invariants

**Every managed window has a valid Client record:**
- Window exists in `clients_` registry
- If kind is Tiled/Floating:
    - `client.monitor < monitors.size()`
    - `client.workspace < monitors[monitor].workspaces.size()`
- Dock/Desktop kinds have monitor/workspace fields but they are meaningless

**client.order values are unique and monotonically increasing:**
- Assigned via `next_client_order_++` on window management
- Used for consistent _NET_CLIENT_LIST ordering

### Focus Consistency Invariants

**Active window is always valid and visible:**
- If `active_window_ != XCB_NONE`:
    - Window exists in `clients_`
    - Window is NOT iconic
    - Window is NOT hidden
    - Window is NOT on a hidden workspace

**Window is focus_eligible IF:**
- Kind is NOT Dock or Desktop
- (accepts_input_focus OR supports_take_focus)

**Additional focus barriers (prevent focus even for eligible windows):**
- Hidden windows (client.hidden == true) - filtered in event handlers (EnterNotify, MotionNotify, ButtonPress)
- Windows on non-visible workspaces
- showing_desktop_ mode blocks all focus except exit actions

### Client State Internal Consistency

**Mutually exclusive states are not both true:**
- NOT (above AND below)

**State flag relationships:**
- iconic ⇒ hidden for NON-STICKY windows (iconic windows always hidden off-screen; sticky windows exception)
- hidden does NOT ⇒ iconic (can be hidden for workspace visibility without being iconic)
- hidden = true ⇒ window is at OFF_SCREEN_X (-20000)
- hidden = false ⇒ window is at on-screen position
- modal ⇒ above: When `set_window_modal(enabled)` called, it calls `set_window_above(enabled)`. When `set_window_modal(false)` called, it calls `set_window_above(false)`. Coupling is one-way from modal to above: `set_window_above()` can be called independently without affecting modal state

### Desktop Index Validity

**Desktop index is in valid range or sticky:**
- desktop < monitors × workspaces_per_monitor
- OR desktop == 0xFFFFFFFF (sticky marker)

### Workspace and Monitor Consistency

**Every tiled window appears in exactly one workspace:**
- Each window in workspace.windows exists in `clients_`
- Each window with Kind::Tiled appears in exactly one workspace
- No duplicate windows across workspaces
- Sticky windows appear in exactly one workspace.windows vector (visible on all via hide_window skip, overlay on other workspaces)

**workspace.focused_window is a best-effort hint:**
- Normally updated correctly on window removal (set to workspace.windows.back() or XCB_NONE)
- May become stale in edge cases:
   - After explicit window move between workspaces (if source workspace's focused_window isn't updated)
   - After unusual state transitions that bypass normal update paths
- May reference an iconic or focus-ineligible window
- `select_focus_candidate()` validates existence and eligibility before using
- If validation fails, falls back to reverse iteration (MRU order)
- When updating after window removal, set to `workspace.windows.back()` or XCB_NONE if empty

### Visibility Conditions

**Window is visible IF:**
- NOT client.hidden
- NOT showing_desktop
- NOT iconic
- (sticky OR workspace == current)

### Initial Values

**Initial values during WM startup:**
- `previous_workspace`: Initially equals `current_workspace` (starts at 0)
- `focused_monitor`: Initially set to monitor 0 during initialization
- `active_window`: Initially XCB_NONE (no focus)

### Floating Window Invariants

**FloatingWindow.geometry must equal Client.floating_geometry after apply_floating_geometry():**
- Client.floating_geometry is authoritative (persistent state)
- FloatingWindow.geometry is transient (runtime state)
- Both always updated together via apply_floating_geometry()
- Violation causes geometry mismatch between state and actual window

**Each xcb_window_t appears at most once in floating_windows_:**
- No duplicate windows in vector
- MRU promotion validates uniqueness before moving

### Fullscreen Invariants

**Fullscreen windows are excluded from tiling layout calculations:**
- Fullscreen windows never appear in `visible_windows` during `rearrange_monitor()`
- Fullscreen windows have dedicated fullscreen_geometry calculation
- Layout algorithm only considers non-fullscreen tiled windows
- Invariant enforced implicitly (fullscreen windows filtered before layout)

---

## Error Handling and Validation

### Error Handling Philosophy

LWM uses graceful error handling to prevent crashes and maintain stability:

**Intentional no-ops**: Many operations return early without error logging for invalid state
- Prevents cascading failures
- Examples: focusing non-existent window, dragging fullscreen window, operations on unmanaged windows

**Bounds checking**: All array/vector access validated before use
- Monitor indices checked against `monitors_.size()`
- Workspace indices clamped to valid range
- Client lookups validate existence before use

**Fallback behaviors**: When operations cannot proceed:
- Return default values or early returns
- Use fallback monitor/monitor 0 when indices are invalid
- Preserve system state rather than crash

### Validation Strategy

**Bounds Checking Reference Table**:

| Function | Bounds Check | Fallback Behavior |
|----------|-------------|-------------------|
| update_floating_visibility | monitor_idx < monitors_.size() | Return early (LOG_TRACE) |
| switch_to_ewmh_desktop | monitor_idx < monitors_.size(), ws_idx < workspaces.size() | Return early (LOG_TRACE) |
| focus_floating_window | client->monitor < monitors_.size() | Return early (LOG_TRACE) |
| apply_maximized_geometry | client->monitor < monitors_.size() | Return early |
| Rule application | target_mon < monitors_.size() | Skip entire rule |
| apply_floating_geometry | Fallback to workspace 0 if invalid monitor index | Use default workspace |
| workspace_index_for_window | Returns std::nullopt for unmanaged windows | Caller handles null |

---

## Window State Machine

### Off-Screen Visibility Architecture

**Purpose**: LWM uses off-screen visibility instead of unmap/map cycles for controlling window visibility.

**Mechanism**:
- Windows always mapped (XCB_MAP_STATE_VIEWABLE) at all times
- Visibility controlled by moving windows to off-screen position: `OFF_SCREEN_X = -20000`
- `client.hidden` flag tracks off-screen state: true = at OFF_SCREEN_X, false = at on-screen position

**Key Functions**:
- `hide_window(window)`: Sets client.hidden=true, moves window to OFF_SCREEN_X (skips sticky windows)
- `show_window(window)`: Sets client.hidden=false only; caller must restore geometry

**Visibility Control Channels**:
1. **Iconification**: `iconify_window()` sets iconic=true AND calls hide_window()
2. **Workspace switches**: `hide_window()` for windows leaving workspace, `show_window()` for entering
3. **Showing Desktop**: `hide_window()` for all non-sticky windows
4. **Sticky windows**: Never hidden by `hide_window()` (early return, remain visible across workspace switches)

**Interaction with ICCCM**:
- With off-screen visibility, ALL UnmapNotify events treated as client-initiated withdraw requests
- WM never unmaps windows (always uses off-screen positioning)
   - No counter tracking exists (unlike traditional unmap-based visibility)

**Function Implementations**:

**hide_window(window)**:

- If window has no Client record: return (intentional no-op).
- If client.sticky: return early (sticky windows never hidden).
- If client.hidden: return early (prevent redundant off-screen moves).
- Sets client.hidden=true.
- Moves window to OFF_SCREEN_X, preserves y coordinate.

Implementation: Uses XCB_CONFIG_WINDOW_X with OFF_SCREEN_X. Caller must flush. Sticky windows skip all processing.

**show_window(window)**:

- If window has no Client record: return (intentional no-op).
- If client.hidden == false: return early (already visible).
- Sets client.hidden=false only.
- Does NOT send configure events or restore position.
- Caller must call `rearrange_monitor()` for tiled windows or `apply_floating_geometry()` for floating windows.
- Desktop windows: LWM never calls hide_window/show_window() on them, so hidden flag never modified. Desktop windows always positioned as background windows below all others.

Implementation: Only clears client->hidden flag. Caller must restore geometry via rearrange_monitor() or apply_floating_geometry(). Desktop windows are never hidden or shown via these functions (they remain as background windows).

---

### Window Classification (EWMH)

```
MapRequest → classify_window()
├─ If already managed → deiconify_window() (remap request)
│  └─ Focus is only set if window is on current workspace of focused monitor (otherwise just deiconifies)
├─ If override-redirect → Ignore (menus, dropdowns)
├─ _NET_WM_WINDOW_TYPE_DESKTOP → Desktop
├─ _NET_WM_WINDOW_TYPE_DOCK → Dock
├─ _NET_WM_WINDOW_TYPE_NOTIFICATION/TOOLTIP/... → Popup (mapped directly, NOT MANAGED)
├─ Transient window → Floating
└─ Normal window → apply rules → Tiled/Floating
```

**Note**: Popup windows (menus, tooltips, notifications) mapped directly but NOT managed. They bypass state machine entirely.

**Initial Iconic State Detection**:
1. Check _NET_WM_STATE_HIDDEN property
2. If not set, check WM_HINTS.initial_state == IconicState
3. Precedence: _NET_WM_STATE_HIDDEN > WM_HINTS.initial_state

---

### State Model

```
                      ┌─────────────────────────────────────────┐
                      │           UNMANAGED                       │
                      └─────────────────┬───────────────────────┘
                                        │ MapRequest
                                        ▼
                      ┌─────────────────────────────────────────┐
                      │           MANAGED                         │
                      │  kind: Tiled/Floating/Dock/Desktop       │
                      │  WM_STATE: Normal/Iconic                 │
                      └─────────────────┬───────────────────────┘
                                        │
                      ┌─────────────────┼───────────────────────┐
                      │                 │                       │
            ┌─────────▼─────────┐  ┌──▼─────────┐
            │     VISIBLE       │  │   ICONIC    │
            │  (mapped,         │  │ (minimized) │
            │   hidden=false,    │  │ (mapped but  │
            │   iconic=false,   │  │   hidden=true,│
            │   on-screen)      │  │   iconic=true,│
            │                   │  │   off-screen) │
            │  State modifiers:  │  │              │
            │  • fullscreen     │  │              │
            │  • above/below    │  │              │
            │  • sticky         │  │              │
            │  • modal          │  │              │
            │  • maximized_*    │  │              │
            │  • shaded         │  │              │
            │  • skip_*         │  │              │
            │  • demands_attent. │  │              │
            └─────────┬─────────┘  └──┬─────────┘
                      │                │
                      └─────────────────┴────────────────────┘
                                        │
                      ┌─────────────────┼─────────────────────┐
                      │                 │                     │
                UnmapNotify    DestroyNotify    Unmanage (error)
                      │                 │                     │
                      └─────────────────┴─────────────────────┘
                                        ▼
                      ┌─────────────────────────────────────────┐
                      │           WITHDRAWN                      │
                      │     (WM_STATE = WithdrawnState)        │
                       └─────────────────────────────────────────┘
 
**State Model Notes:**
- Top-level window states: UNMANAGED, MANAGED (with VISIBLE/ICONIC substates), WITHDRAWN (ICCCM WM_STATE)
- **VISIBLE** is logical category defined by `!iconic && !hidden`. Includes windows that may have fullscreen, maximized, or other state modifiers. Fullscreen windows with `hidden=true` (e.g., on non-current workspace) are NOT in VISIBLE category.
- `hidden` is physical state flag (positioned off-screen at OFF_SCREEN_X)
- `iconic` is logical state flag (minimized by user, WM_STATE Iconic)
- **iconic=true implies hidden=true for NON-STICKY windows** (minimized windows are off-screen; sticky windows exception)
- **hidden=true does NOT imply iconic=true** (workspace switches also hide windows)
- **hidden=false implies iconic=false for NON-STICKY windows** (on-screen windows cannot be minimized)
- **Exception for sticky windows**: Iconic sticky windows have iconic=true but hidden=false (hide_window() returns early for sticky windows, so they remain at on-screen position while iconic flag is set)
- State modifiers apply to VISIBLE windows: fullscreen, above, below, sticky, maximized, shaded, modal
- `fullscreen` can combine with VISIBLE state; fullscreen windows excluded from tiling

---

### State Truth Table

| hidden | iconic | fullscreen | Visible On-Screen? | Valid? | Notes |
|--------|--------|-----------|-------------------|--------|-------|
| true   | true   | false     | No                | Yes    | Iconic (minimized) window |
| true   | true   | true      | No                | Yes    | Iconic fullscreen window (fullscreen flag preserved while off-screen) |
| true   | false  | false     | No                | Yes    | Hidden (workspace switch) |
| true   | false  | true      | No                | Yes    | Fullscreen on non-visible workspace |
| false  | false  | false     | Yes               | Yes    | Normal visible window |
| false  | false  | true      | Yes               | Yes    | Visible fullscreen window |
| false  | true   | any       | Yes (on-screen, marked minimized) | **SPECIAL** | Only for sticky windows: hide_window() returns early, so iconic sticky windows have hidden=false (they remain at their on-screen position while iconic flag is set)

**fullscreen+iconic**: Window retains fullscreen flag while off-screen until deiconified (fullscreen and iconic are NOT mutually exclusive)

---

### State Conflicts

- **Modal and Above**: Modal windows automatically stacked above others (setting modal also sets above). However, above flag can be set independently without making window modal. This is one-way coupling: modal ⇒ above, but above ⇏ modal.
- **Fullscreen and Maximized**: Fullscreen supersedes maximized. When fullscreen enabled, maximized flags cleared. Maximization changes ignored while window is fullscreen.
- **Above and Below**: Mutually exclusive - window cannot be both above and below simultaneously.
- **Fullscreen and Iconic**: Windows can be fullscreen while iconic (off-screen). Fullscreen geometry applied when window becomes deiconified and on current workspace.

---

### State Transitions

#### State Transition Summary

| From State | To State | Trigger | Key Actions |
|------------|-----------|---------|-------------|
| UNMANAGED | MANAGED | MapRequest | Create Client, classify, configure, map window |
| MANAGED | WITHDRAWN | UnmapNotify/DestroyNotify | WM_STATE Withdrawn, erase from clients_, remove from workspace |
| VISIBLE | ICONIC | iconify_window() | Set iconic=true, hide_window(), WM_STATE Iconic |
| ICONIC | VISIBLE | deiconify_window() | Set iconic=false, show_window(), restore geometry |
| VISIBLE | FULLSCREEN | set_fullscreen(true) | Save geometry, set fullscreen flag, apply fullscreen geometry |
| FULLSCREEN | VISIBLE | set_fullscreen(false) | Restore geometry, clear fullscreen flag |
| VISIBLE | MAXIMIZED | set_window_maximized() | Save geometry, set maximized flags, apply maximized geometry |
| MAXIMIZED | VISIBLE | set_window_maximized(false) | Restore geometry, clear maximized flags |
| VISIBLE | ABOVE | set_window_above(true) | Set above flag, restack above normal windows |
| ABOVE | VISIBLE | set_window_above(false) | Clear above flag, restack normally |
| VISIBLE | BELOW | set_window_below(true) | Set below flag, restack below all windows |
| BELOW | VISIBLE | set_window_below(false) | Clear below flag, restack normally |
| VISIBLE | STICKY | set_window_sticky(true) | Set sticky flag, _NET_WM_DESKTOP=0xFFFFFFFF |
| STICKY | VISIBLE | set_window_sticky(false) | Clear sticky flag, _NET_WM_DESKTOP=actual workspace |
| VISIBLE | SHOWING_DESKTOP | _NET_SHOWING_DESKTOP true | Hide non-sticky windows, clear focus |
| SHOWING_DESKTOP | VISIBLE | _NET_SHOWING_DESKTOP false | Show hidden windows, rearrange, focus_or_fallback() |
| FOCUS | NO_FOCUS | Last window removed, empty workspace, pointer on root | active_window_=XCB_NONE, clear_focus() |
| NO_FOCUS | FOCUS | Focus request, EnterNotify, ButtonPress | Set active_window_, focus window |
| FOCUS | FOCUS | focus_next/prev | Cycle to next/previous eligible window |

---

#### Window Lifecycle

```
MapRequest
    ↓
If already managed:
    ├─ Determine focus = (window.monitor == focused_monitor_ && window.workspace == current_workspace)
    ├─ deiconify_window(window, focus)
    └─ Return (deiconify only, do not remanage)
    ↓
If override-redirect → Ignore (menus, dropdowns bypass state machine)
    ↓
classify_window() → Kind (Tiled/Floating/Dock/Desktop/Popup)
    ├─ If Popup (menus, tooltips, notifications): Map directly, NOT MANAGED, return
    └─ Continue for Tiled/Floating/Dock/Desktop
    ↓
apply_window_rules()
    ├─ Can override EWMH states except Dock/Desktop/Popup types
    └─ Applies rule geometry or uses placement logic
    ↓
Create Client record (order = next_client_order_++)
    ↓
Read initial EWMH state (precedence: _NET_WM_STATE_HIDDEN > WM_HINTS.initial_state)
    ├─ Check _NET_WM_STATE_HIDDEN → start_iconic
    └─ If not set, check WM_HINTS.initial_state → start_iconic
    ↓
If Floating: Create FloatingWindow, determine placement
    ↓
Add to workspace.windows (Tiled) or floating_windows_ (Floating)
    ↓
Set WM_STATE (Normal/Iconic)
    ↓
Apply geometry-affecting states (fullscreen, maximized)
    ├─ Fullscreen: geometry applied if not iconic
    └─ Maximized: geometry saved but not applied if fullscreen
    ↓
Configure geometry
    ├─ Apply rule geometry, fullscreen geometry, or placement logic
    └─ Send synthetic ConfigureNotify after applying geometry
    ↓
xcb_map_window() (always, even if will be hidden)
    ↓
If start_iconic or not visible: hide_window() (move off-screen)
    ↓
Apply non-geometry states (above, below, skip_*)
    ↓
Update _NET_CLIENT_LIST    ↓
[Window active] → Focus, drag, state changes, workspace moves
    ↓
UnmapNotify / DestroyNotify
    ↓
handle_window_removal()
    ├─ Set WM_STATE = Withdrawn
    ├─ Erase pending_kills_, pending_pings_
    ├─ Erase clients_[window]
    ├─ Remove from workspace.windows or floating_windows_
    ├─ Update workspace.focused_window (set to workspace.windows.back() or XCB_NONE if empty)
    ├─ If was active_window_:
    │  ├─ If removed window's workspace is the **current workspace** of its monitor AND that monitor is the currently focused monitor:
    │  │  └─ focus_or_fallback(removed window's monitor)
    │  └─ Else:
    │     └─ clear_focus()
    └─ Rearrange monitor, update _NET_CLIENT_LIST```

**Note**: LWM restores focus only when the removed window was on the **current workspace** of its monitor AND that monitor is the currently focused monitor. The workspace.focused_window update sets it to `workspace.windows.back()` or XCB_NONE if empty.

---

#### Fullscreen Transition

```
[Trigger: keybind or _NET_WM_STATE]
    ↓
set_fullscreen(window, enabled)
    ↓
If enabled:
    ├─ Check already fullscreen?
    ├─ Save geometry → client.fullscreen_restore
    ├─ Set client.fullscreen = true
    ├─ Clear above/below (incompatible)
    ├─ Clear maximized (superseded)
    ├─ Set _NET_WM_STATE_FULLSCREEN
    ├─ Configure to fullscreen geometry
    └─ Stack above all
    ↓
If disabled:
    ├─ Check already not fullscreen?
    ├─ Set client.fullscreen = false
    ├─ Clear _NET_WM_STATE_FULLSCREEN
    ├─ Restore geometry from fullscreen_restore
    └─ Rearrange (tiled) or apply_floating_geometry (floating)
```

**Fullscreen Window Visibility**:
- Fullscreen windows on non-visible workspaces have hidden=true (off-screen) but fullscreen=true
- When workspace becomes visible, show_window() and apply_fullscreen_if_needed() restore on-screen geometry
- During showing_desktop mode, fullscreen windows (non-sticky) are hidden like normal windows

**apply_fullscreen_if_needed() Preconditions**:
1. Window must be fullscreen (`client.fullscreen == true`)
2. Window must not be iconic (`client.iconic == false`)
3. Client must exist in `clients_`
4. Client must have valid monitor index (`client.monitor < monitors_.size()`)
5. Client's workspace must match the monitor's current workspace

If any precondition fails, the function returns early without applying geometry.

---

#### Maximized Transition

```
[Trigger: keybind or _NET_WM_STATE]
    ↓
set_window_maximized(window, horiz, vert)
    ↓
If not fullscreen (maximize changes ignored when fullscreen):
    ├─ If enabling (horz or vert):
    │  ├─ Save geometry → client.maximize_restore (if not already set)
    │  ├─ Set client.maximized_horz = horiz
    │  ├─ Set client.maximized_vert = vert
    │  ├─ Set _NET_WM_STATE_MAXIMIZED_HORZ/VERT
    │  └─ Apply maximized geometry (floating only, working_area dimensions)
    │     ├─ maximized_horz only: width fills working_area, height unchanged
    │     ├─ maximized_vert only: height fills working_area, width unchanged
    │     └─ Both: window fills entire working_area
    └─ If disabling (both horz and vert false):
       ├─ Set client.maximized_horz = false
       ├─ Set client.maximized_vert = false
       ├─ Clear _NET_WM_STATE_MAXIMIZED_HORZ/VERT
       ├─ Restore geometry from maximize_restore
       └─ apply_floating_geometry (floating only)
```

**Note**: Tiled windows ignore maximize state (layout controls geometry). Maximize state flags ARE stored on tiled windows and `maximize_restore` geometry IS saved when maximizing tiled windows. This is intentional behavior to preserve state for future floating conversion. Maximize state changes are ignored when a window is fullscreen.

---

#### Iconify Transition

```
[Trigger: keybind, _NET_WM_STATE, or WM_CHANGE_STATE]
    ↓
iconify_window(window)
    ↓
Check already iconic?
    ↓
Set client.iconic = true
    ↓
Set WM_STATE = IconicState
    ↓
Set _NET_WM_STATE_HIDDEN = true
    ↓
hide_window() (move off-screen, NOT unmapping)
    ↓
If was active_window_:
    ├─ If on focused_monitor_ AND on current_workspace → focus_or_fallback()
    └─ Else → clear_focus()
    ↓
Flush connection
```

**Iconic Fullscreen Windows**:
- Fullscreen windows that become iconic have fullscreen=true but hidden=true (off-screen)
- When deiconified, deiconify_window() calls apply_fullscreen_if_needed() which:
  - Verifies window is fullscreen AND not iconic AND on current workspace
  - Sends sync request
  - Configures window to fullscreen geometry
  - Sends synthetic ConfigureNotify
  - Restacks window above all
- Iconic fullscreen windows on non-current workspaces remain off-screen until both deiconified AND workspace becomes active

---

#### Sticky Toggle

```
[Trigger: keybind or _NET_WM_STATE]
    ↓
set_window_sticky(window, enabled)
    ↓
If enabled:
    ├─ Set client.sticky = true
    ├─ Set _NET_WM_STICKY = true
    ├─ Set _NET_WM_DESKTOP = 0xFFFFFFFF
    └─ Update visibility (show on all workspaces)
    ↓
If disabled:
    ├─ Set client.sticky = false
    ├─ Clear _NET_WM_STICKY
    ├─ Set _NET_WM_DESKTOP = actual workspace
    └─ Update visibility (show only on current workspace)
```

**For complete sticky window behavior documentation, see [Workspace Management → Sticky Windows](#sticky-windows).**

**Edge Cases for Sticky Toggle**:

**Iconic Window Becoming Sticky**:
- If set_window_sticky(true) is called on an iconic (off-screen, hidden=true) window:
   - sticky flag is set
   - window remains off-screen (hidden=true, at OFF_SCREEN_X)
   - No call to show_window() occurs
    - When deiconified, window becomes visible on current workspace, then behaves as sticky on subsequent workspace switches
 
**Sticky Window Becoming Non-Sticky**:
- If set_window_sticky(false) is called on an iconic window:
   - sticky flag is cleared
   - _NET_WM_DESKTOP is set to actual workspace (the workspace where the window was when it became sticky)
   - Window remains iconic (still off-screen)
   - When deiconified, window becomes visible on its assigned workspace only

**Fullscreen Window Becoming Sticky**:
- If sticky is toggled on a fullscreen window:
   - fullscreen flag remains set
   - sticky flag is set/cleared
   - If sticky on non-current workspace: window is off-screen (hidden) but fullscreen flag is set
   - When switching to its workspace: apply_fullscreen_if_needed() applies fullscreen geometry
- Fullscreen windows respect sticky flag for workspace visibility (like normal windows)

---

## Event Loop

### Main Loop Structure

```
run()
├─ while (running_)
│  ├─ Calculate timeout from pending operations
│  ├─ poll() for X events or timeout
│  ├─ while (event = xcb_poll_for_event())
│  │  └─ handle_event(*event)
│  ├─ handle_timeouts()
│  │  ├─ Clean up expired pending_pings_ entries
│  │  └─ Force-kill windows with expired pending_kills_
│  └─ Check for X connection errors
│     └─ If error: LOG_ERROR and initiate shutdown
```

### Event Handlers (wm_events.cpp)

| Event | Handler | Effect |
|-------|---------|--------|
| MapRequest | handle_map_request | LWM classifies and manages window. Handles deiconify if already managed |
| UnmapNotify | handle_window_removal | With off-screen visibility, ALL unmaps are client-initiated withdraw requests. LWM calls handle_window_removal() to unmanage window |
| DestroyNotify | handle_window_removal | LWM unmanages window |
| EnterNotify | handle_enter_notify | LWM implements focus-follows-mouse. Ignores hidden windows. Updates focused_monitor on root window entry |
| MotionNotify | handle_motion_notify | LWM re-establishes focus in window. Ignores hidden windows. Updates focused_monitor if crossing monitor |
| ButtonPress | handle_button_press | LWM focuses window and begins drag. Ignores hidden windows. Updates focused_monitor |
| ButtonRelease | handle_button_release | LWM ends drag |
| KeyPress | handle_key_press | LWM executes keybind actions |
| KeyRelease | handle_key_release | LWM tracks for auto-repeat detection |
| ClientMessage | handle_client_message | LWM handles EWMH/ICCCM commands |
| ConfigureRequest | handle_configure_request | LWM handles geometry requests. For tiled windows: send synthetic ConfigureNotify. For floating windows: apply geometry within size hints. For fullscreen windows: apply fullscreen geometry. For hidden windows, the configure request is applied normally. If the request changes the x coordinate, the window moves from OFF_SCREEN_X to the new position. Subsequent visibility updates (via rearrange_monitor, workspace switch, or other triggers) may re-hide the window if it should not be visible. This is intentional behavior - the window briefly becomes visible at the requested position, then visibility management reasserts the correct state. |
| PropertyNotify | handle_property_notify | LWM tracks state changes, title, hints, sync counter, struts, and user_time_window indirection for _NET_WM_USER_TIME |
| Expose | handle_expose | No-op (internal bar removed). External bars are handled via struts. |
| SelectionClear | (handled in run) | New WM taking over. LWM exits |
| RANDR change | handle_randr_screen_change | LWM handles monitor hotplug |

### Time Tracking

- `last_event_time_` - Updated from X event timestamps
- Used for focus stealing prevention (user_time comparison)
- Used for auto-repeat detection (same KeyPress/KeyRelease timestamp)

### Unhandled Events

The following X events are intentionally not handled by LWM:

**XCB_FOCUS_IN**: LWM does not handle focus-in events. Rationale: Focus is managed proactively by LWM through SetInputFocus calls. Reactive focus management would cause focus conflicts and race conditions. LWM's proactive focus model ensures consistent focus state without needing to track FOCUS_IN events.

**XCB_FOCUS_OUT**: LWM does not handle focus-out events. Rationale: LWM always knows which window should be focused through its own state tracking. Tracking FOCUS_OUT events would be redundant and could introduce inconsistencies between X server focus state and LWM's internal state.

**XCB_LEAVE_NOTIFY**: LWM extracts the timestamp from LeaveNotify events (via extract_event_time()) but does not handle them. Rationale: LeaveNotify is only used for timestamp tracking for focus stealing prevention. Actual focus behavior is managed through EnterNotify events and explicit focus operations.

---

## Focus System

### Global Focus State

**NO_FOCUS**: `active_window_ = XCB_NONE` (not a window state)

Triggered when:
- Last window unmanaged and no replacement exists
- Pointer enters root window (empty space)
- Entering showing_desktop mode
- focus_or_fallback() finds no eligible candidates

Note: Windows themselves have VISIBLE or ICONIC states; NO_FOCUS is a global WindowManager condition.

### Focus Eligibility

**is_focus_eligible(window)** function definition:

```
is_focus_eligible(window) =
    NOT (kind == Dock OR kind == Desktop)
    AND (accepts_input_focus OR supports_take_focus)
```

This is the formal definition of focus eligibility. Additional barriers can prevent focus even for eligible windows - see [Focus Barriers](#focus-barriers) below.

**Where this function is used**:
- In focus restoration logic (focus_or_fallback)
- When validating candidate windows
- NOT in event handlers (those filter differently)

**What it checks**:
- Window kind (excludes Dock and Desktop)
- WM_HINTS.input flag
- WM_PROTOCOLS for WM_TAKE_FOCUS support

**What it does NOT check**:
- `client.hidden` - filtered in event handlers instead
- `client.iconic` - handled via deiconification transition
- `showing_desktop_` - checked in focus functions directly
- Workspace visibility - checked in focus functions directly

### Focus Assignment

**focus_window(window)** - Tiled windows
1. Check not showing_desktop
2. If iconic: deiconify first (clears iconic flag)
3. Check is_focus_eligible
4. Call focus_window_state() - may switch workspace
5. Clear all borders (set all windows to black pixel)
6. Apply focused border visuals only when target window is not fullscreen
7. Send WM_TAKE_FOCUS if supported
8. Set X input focus
9. Update _NET_ACTIVE_WINDOW
10. Restack transients
      - Restacks all visible, non-iconic transient windows (where client.transient_for == parent)
      - Skips hidden, iconic, or transients on other workspaces
      - Also occurs when showing floating windows via update_floating_visibility()
11. Update _NET_CLIENT_LIST (and _NET_CLIENT_LIST_STACKING via restack_transients)

**restack_transients()** - Restacks modal/transient windows above parent:
- Identifies transients via client.transient_for field
- Only restacks transients that are:
  - Visible (client.hidden == false)
  - Not iconic
  - On current workspace
- Skips transients on other workspaces
- Ensures modal windows stay above parent during focus changes

**focus_floating_window(window)** - Floating windows
1. Same checks as tiled (including NOT hidden)
2. Promote to end of floating_windows_ (MRU ordering)
3. Stack above (XCB_STACK_MODE_ABOVE)
4. Switch workspace if needed
5. Apply focused border visuals only when target window is not fullscreen

**focus_or_fallback(monitor)** - Smart focus selection
1. Build candidates (order of preference):
    - `workspace.focused_window` if exists in workspace AND eligible (validated to exist)
    - Current workspace tiled windows (reverse iteration = MRU)
    - Sticky tiled windows from other workspaces (reverse iteration)
    - Floating windows visible on monitor (reverse iteration = MRU)
2. Call focus_policy::select_focus_candidate()
3. Focus selected or clear focus

**Note**: Sticky tiled windows from non-current workspaces are included in the candidate list (visible across all workspaces).

**Empty workspace behavior**: When switching to an empty workspace or when the last window on a workspace is removed, `focus_or_fallback()` finds no candidates and clears focus (sets `active_window_ = XCB_NONE`).

### Focus Policy

**Focus-Follows-Mouse**
- When EnterNotify occurs on a window, LWM focuses the window if it is focus_eligible
- Filter: mode=NORMAL, detail≠INFERIOR
- When MotionNotify occurs within a window, LWM re-establishes focus if it was lost
- Hidden windows (client.hidden == true) are filtered out in EnterNotify, MotionNotify, and ButtonPress handlers
   - This prevents off-screen windows from receiving focus
   - Check occurs early, returns immediately for hidden windows
   - Note: is_focus_eligible() does NOT check client.hidden; filtering happens in event handlers

**Focus Barriers**:
The following conditions can prevent focus even for focus-eligible windows:
1. **showing_desktop_ == true** - Blocks all focus except desktop mode exit
2. **client.hidden == true** - Off-screen windows (filtered in event handlers)
3. **iconic windows** - For NON-STICKY windows: iconic ⇒ hidden, so they are blocked by hidden check. For sticky windows: iconic windows have hidden=false but are still blocked from receiving focus because deiconification is required before focusing; focus operations explicitly check and handle iconic windows.
4. **Dock and Desktop kinds** - These window kinds are never focus-eligible by is_focus_eligible() definition.
5. **Windows on non-visible workspaces** - Wrong workspace
4. **Windows on non-visible workspaces** - Wrong workspace

**Note**: The iconic barrier is NOT checked in is_focus_eligible(). Instead, iconic windows are handled via automatic deiconification transition:
- When focus is requested on an iconic window, focus_window() deiconifies it first (sets iconic=false, hidden=false for sticky windows)
- NON-STICKY iconic windows: deiconification makes them on-screen (clears hidden flag)
- STICKY iconic windows: deiconification clears iconic flag while maintaining on-screen position (hidden already false)
- Event handlers filter iconic windows via hidden check for non-sticky windows (iconic ⇒ hidden)

**Monitor Crossing**
- When pointer moves to different monitor, LWM sets `focused_monitor_` to new monitor (via update_focused_monitor_at_point())
- The `focused_monitor_` update may clear focus: When pointer enters root window or an unmanaged area, `focus::pointer_move()` returns `clear_focus=true`, triggering `clear_focus()`
- LWM does NOT clear focus when pointer enters a managed window on the new monitor
- If pointer lands directly on a window on new monitor, that window becomes focused
- If pointer lands on empty space (root window), focus remains cleared until pointer enters a window

**Click-to-Focus**
- ButtonPress on window → Focus immediately

**Focus Restoration**

LWM uses a two-tier focus restoration model:

**1. Workspace focus memory** (tiled windows only):
- Each Workspace.focused_window stores the last-focused tiled window
- When updating after window removal, LWM sets it to `workspace.windows.back()` (most recent window) or XCB_NONE if empty
- This is a best-effort value that may become stale (e.g., after window removal, when the focused window moves to a different workspace)
- Callers validate existence and eligibility before using it
  - select_focus_candidate() validates workspace.focused_window before using it
  - If validation fails (window not in workspace, iconic, or focus-ineligible), falls back to reverse iteration through workspace.windows

**2. Global floating window search** (MRU order):
- When workspace focus memory is not applicable or validation fails, LWM searches floating_windows_ in reverse iteration (MRU) for fallback focus restoration

**Focus restoration on window removal**:
- LWM calls handle_window_removal() when UnmapNotify or DestroyNotify is received
- handle_window_removal() sets WM_STATE = Withdrawn, erases from clients_, removes from workspace/floating, and updates workspace.focused_window
- If the removed window was active_window_:
  - If removed window's workspace is the **current workspace** of its monitor AND that monitor is the currently focused monitor: LWM calls focus_or_fallback(removed window's monitor) to restore focus
  - Otherwise: LWM calls clear_focus() (different monitor/workspace)
- This conditional logic ensures focus is only restored when the removed window was on the currently viewed workspace

**Focus restoration on workspace switch**:
- When switching to a workspace that contains the active window, that window remains focused
- When switching to a different workspace, LWM calls focus_or_fallback() to select a new focus target on the new workspace

**INFERIOR event filtering**:
- EnterNotify with detail=INFERIOR is filtered out
- INFERIOR means pointer entered a window because a child window closed, not because mouse moved
- This is a spurious event that should be ignored

### Focus Stealing Prevention

**_NET_ACTIVE_WINDOW source=1 (application)**
- LWM compares request timestamp with active_window's user_time
- If timestamp == 0 → Focus allowed (no timestamp check)
- If request is older → LWM sets demands_attention instead of focusing
- Only newer timestamps can steal focus

**User Time Window Indirection**:

- `_NET_WM_USER_TIME` property may be on `Client.user_time_window` instead of main window.
- `get_user_time()` implementation: Checks if Client.user_time_window != XCB_NONE; if set, queries property from user_time_window instead of main window; otherwise, queries from main window.
- LWM tracks PropertyNotify events on user_time_window during window management. When _NET_WM_USER_TIME changes, LWM finds the parent Client and updates parent Client.user_time.
- If PropertyNotify arrives on user_time_window not associated with any client, LWM silently ignores the update (no parent found).
- Focus stealing prevention uses parent Client.user_time for comparison.
- Race condition: If window is unmanaged after finding match but before get_client(), LWM silently drops the update.
- _NET_WM_PING response may also come from user_time_window (data[2] = ping origin).

**Note**: See [EWMH Protocol → Ping-Kill Protocol](#ping-kill-protocol) for detailed user_time_window handling during ping/kill operations.

**_NET_ACTIVE_WINDOW source=2 (pager)**
- LWM always allows pager focus requests (no timestamp check)

### Focus Transition Sequence

```
[Trigger: EnterNotify, ButtonPress, keybind, _NET_ACTIVE_WINDOW]
    ↓
focus_window() or focus_floating_window()
    ↓
Check showing_desktop (reject if true)
    ↓
If iconic: deiconify first
    ↓
Check is_focus_eligible
    ↓
focus_window_state():
    ├─ Find window's monitor/workspace
    ├─ If not sticky AND workspace != current:
    │  ├─ workspace_changed = true
    │  └─ Switch workspace
    ├─ Update workspace.focused_window
    ├─ Set active_monitor_ = monitor
    └─ Set active_window_ = window
    ↓
If workspace_changed:
    ├─ hide_window() for non-sticky windows (old workspace)
    ├─ Rearrange monitor
    └─ Update floating visibility
    ↓
Clear all borders
    ↓
If focused window is not fullscreen:
    └─ Apply focused border visuals
    ↓
Send WM_TAKE_FOCUS (if supported)
    ↓
SetInputFocus
    ↓
Update _NET_ACTIVE_WINDOW
    ↓
Clear demands_attention
    ↓
Set _NET_WM_STATE_FOCUSED
    ↓
Update client.user_time
    ↓
Focus transition does NOT reapply fullscreen geometry
    ↓
Restack transients above parent (visible, non-iconic transients only):
  └─ Skips hidden, iconic, or transients on other workspaces
    ↓
Update _NET_CLIENT_LIST (and _NET_CLIENT_LIST_STACKING via restack_transients)
```

### WM_TAKE_FOCUS Protocol

**Purpose**: Support windows with `input=False` in WM_HINTS that cannot receive `SetInputFocus`.

**When Sent**:
- Always sent when focusing any managed window
- Sent via `WM_PROTOCOLS` ClientMessage (not directly as TAKE_FOCUS)

**Protocol Flow**:
```
focus_window() / focus_floating_window()
    ↓
send_wm_take_focus(window, timestamp)
    ├─ Check WM_PROTOCOLS atom exists
    ├─ Check window supports WM_TAKE_FOCUS
    └─ Send ClientMessage with:
        ├─ type = WM_PROTOCOLS
        ├─ data[0] = WM_TAKE_FOCUS atom
        └─ data[1] = timestamp (last_event_time_ or XCB_CURRENT_TIME)
    ↓
    └─ Client must call SetInputFocus in response (ICCCM requirement)
```

**Input Focus Logic**:
```
should_set_input_focus(window):
    ├─ If WM_HINTS not specified → allow (default true)
    ├─ If WM_HINTS.input == True → allow
    └─ If WM_HINTS.input == False → disallow
```

- If allowed: Both WM_TAKE_FOCUS and SetInputFocus sent
- If disallowed: Only WM_TAKE_FOCUS sent (client must focus itself)

---

## Workspace Management

### Workspace Structure

```
Monitor
├─ workspaces: [Workspace, Workspace, ...]
├─ current_workspace: N
└─ previous_workspace: M

Workspace
├─ windows: [window1, window2, ...]  // Tiling order
└─ focused_window: windowX  // Last-focused
```

### Sticky Windows

Sticky windows have an assigned workspace but are visible on all workspaces via special handling.

**Core Behavior:**
- Have an assigned workspace (for placement/focus tracking)
- Never hidden by `hide_window()` - function returns early for sticky windows
- Included in exactly one `Workspace::windows` vector
- Visible on all workspaces due to:
  - hide_window() returns early (doesn't set hidden=true or move off-screen)
  - Workspace tiling algorithm filters sticky windows from layout
  - Layout excludes sticky windows from `visible_windows` passed to layout algorithm
- `_NET_WM_DESKTOP = 0xFFFFFFFF` (sticky marker)

**Iconification:**
- When sticky window is iconified: `iconic=true`, `hidden=false` (sticky exception to iconic ⇒ hidden rule)
- Iconic sticky windows remain physically on-screen but cannot receive focus
- Deiconification restores normal focus eligibility

**Showing Desktop Mode:**
- Non-sticky windows are hidden (moved off-screen)
- Sticky windows remain visible (hide_window returns early)
- Iconic sticky windows remain visible but not focusable

**Focus Behavior:**
- Focusing sticky window does NOT switch workspaces
- Sticky windows are included in focus candidate list across all workspaces

**Fullscreen Sticky Windows:**
- Fullscreen flag applies normally
- Sticky behavior for visibility still applies
- On workspace switch: apply_fullscreen_if_needed() applies geometry

**See [Window State Machine → Sticky Toggle](#sticky-toggle) for transition details and edge cases.**

### Desktop Mapping

```
desktop_index = monitor_idx * workspaces_per_monitor + workspace_idx

_NET_CURRENT_DESKTOP = active_monitor's current workspace
_NET_NUMBER_OF_DESKTOPS = monitors × workspaces_per_monitor
_NET_DESKTOP_VIEWPORT = Each workspace's monitor origin
```

### Previous Workspace Tracking

`monitor.previous_workspace` is per-monitor, not global. Updated on:

1. **Explicit workspace switch**: `workspace_policy::apply_workspace_switch()` sets to old workspace
2. **Focus-induced workspace switch**: `focus_window_state()` sets to old workspace when focus triggers switch

Used for `toggle_workspace()` behavior to restore previous workspace. Note that `previous_workspace` is independent per monitor.

### Workspace Switch

```
switch_workspace(target_ws)
├─ Validate workspace index
├─ workspace_policy::apply_workspace_switch()
│  ├─ Validate workspace index (returns nullopt if invalid - out of bounds, negative, or same as current)
│  ├─ Update previous_workspace = current
│  ├─ Update current_workspace = target
│  └─ Return WorkspaceSwitchResult{ old, target }
├─ hide_window() for floating windows (iterates global floating_windows_, filters by: on focused_monitor, non-sticky, on old_workspace)
├─ hide_window() for tiled windows (iterates old_workspace.windows directly, filters by: non-sticky)
├─ conn_.flush()  ← Critical sync point!
├─ update_ewmh_current_desktop()
├─ rearrange_monitor(new workspace)
│  ├─ For each visible window: show_window() (clears hidden flag)
│  └─ layout_.arrange() (applies on-screen geometry)
├─ update_floating_visibility()  ← Show new workspace's floating windows, hide old ones
├─ focus_or_fallback(monitor)
├─ conn_.flush()  ← Final sync point after all updates
└─ Update bars
```

**Critical Ordering**:
1. Hide old workspace windows (floating first, then tiled)
2. Flush X connection to ensure hide operations complete
3. Show new workspace via rearrange_monitor and update_floating_visibility

**Rationale for floating-first hiding**:
- Floating windows are hidden BEFORE tiled windows to prevent visual glitches
- If tiled windows were hidden first, old floating windows might briefly appear over new workspace content during workspace switch
- The flush after hiding operations ensures all hide configurations are applied before new workspace content is rendered
- This prevents "flash" artifacts during workspace transitions

**Off-Screen Visibility**: Windows are hidden using hide_window(), NOT unmapped.

**Visibility Restoration**: See [Window State Machine → Off-Screen Visibility Architecture](#off-screen-visibility-architecture) for hide_window/show_window implementation details. During workspace switch:
- hide_window() moves tiled windows off-screen (sets client.hidden = true, moves to OFF_SCREEN_X)
- rearrange_monitor() restores visibility by calling show_window() for each visible window (clears hidden flag) and calculating geometry for all windows in the new workspace
- show_window() is called for tiled windows before layout_.arrange(), not implicitly via layout
- For floating windows: update_floating_visibility() calls show_window()/hide_window() explicitly

 ### Workspace Toggle

```
toggle_workspace()
├─ Check workspace count <= 1 → Return (no toggle with only 1 workspace)
├─ Check previous_workspace invalid or same as current → Return
├─ Auto-repeat detection (same keysym, same timestamp as KeyRelease)
├─ target = monitor.previous_workspace
└─ switch_workspace(target)
```

**Early Return Conditions**:
- Workspace count <= 1: No toggle possible with only one workspace
- previous_workspace invalid: After monitor hotplug or workspace configuration changes, previous_workspace may be out-of-bounds. Returns without switching (same as 'same as current' case).
- previous_workspace == current: Already on previous workspace, no action needed

**Auto-Repeat Prevention**:
- X11 auto-repeat sends KeyRelease → KeyPress (identical timestamps)
- toggle_workspace() tracks last_toggle_keysym_ and last_toggle_release_time_
- Blocks KeyPress if same keysym AND same timestamp as KeyRelease
- After allowing new toggle, last_toggle_release_time_ is reset to 0
- Prevents multiple workspace toggles from single key hold

**Note**: toggle_workspace() updates previous_workspace on each switch via switch_workspace()'s call to workspace_policy::apply_workspace_switch(). The previous_workspace value reflects the workspace that was active before the switch.

Example: User on workspace 0, previous_workspace = 1
- toggle_workspace() switches to workspace 1
- previous_workspace becomes 0 (so next toggle returns to 0)

### Move Window to Workspace

**Tiled windows**
```
move_window_to_workspace(target_ws)
├─ workspace_policy::move_tiled_window()
│  ├─ Remove from source workspace.windows
│  ├─ Add to target workspace.windows
│  └─ Update source/target focused_window
├─ Update Client.monitor, Client.workspace
├─ Set _NET_WM_DESKTOP
├─ hide_window() if target not visible
├─ Rearrange affected monitor(s)
├─ Focus fallback in source workspace
└─ Update bars
```

**Floating windows**
- Update Client.monitor, Client.workspace
- Reposition to target monitor's working area
- Update visibility on both monitors
- Focus moved window if visible
- Note: If floating window crosses monitor boundary via geometry update (not explicit move), `update_floating_monitor_for_geometry()` auto-assigns to new monitor without focus restoration

---

## Monitor Behavior

### Monitor Hotplug

**Trigger**: RANDR screen change (monitor hotplug, resolution change)

```
handle_randr_screen_change()
├─ Exit fullscreen for all windows (prevents stale fullscreen_restore)
│  ├─ Clear fullscreen flag from all clients
│  ├─ Clear fullscreen_restore from all clients
│  └─ Clear fullscreen_monitors from all clients (indices invalid)
├─ Save window locations by monitor NAME (not index):
│  ├─ Tiled: monitor_name + workspace_index
│  └─ Floating: monitor_name + workspace_index + geometry
├─ Detect monitors (detect_monitors)
├─ If monitors_.empty() → create_fallback_monitor() (default monitor with screen dimensions)
├─ Update struts from dock windows
├─ Restore windows:
│  ├─ Find monitor by name (if not found, falls back to monitor 0)
│  ├─ Clamp workspace to valid range (falls back to current workspace if invalid)
│  ├─ Restore Client.monitor/workspace
│  └─ For floating: reposition if target monitor exists
│     └─ Uses floating::place_floating() on new monitor
├─ Restore focused monitor by name (if not found, defaults to monitor 0)
├─ Update EWMH (all root properties)
├─ Rearrange all monitors
└─ focus_or_fallback()
```

**Edge Cases:**
- All monitors disconnected: Creates fallback monitor with screen dimensions, name="default"
- Monitor name not found: Windows silently fall back to monitor 0
- Focused monitor not found: Defaults to monitor 0

### Empty Monitor State

**When monitors_.empty() == true**:
- Occurs when all monitors are disconnected (no X11 outputs)
- Several operations handle this case:
  - `fullscreen_geometry_for_window()` returns empty geometry
  - `end_drag()` aborts silently
  - `begin_tiled_drag()` rejects
  - `begin_drag()` on fullscreen windows rejects
- Fallback behavior: Return default values or early returns without errors
- No explicit user notification; WM continues operating with fallback monitor

**Rationale**:
- Saving by monitor NAME handles monitors being turned off/on (index changes but name persists)
- Exiting fullscreen before reconfiguration prevents stale geometries
- Clearing fullscreen_monitors prevents invalid monitor indices after hotplug

### Monitor Switching

**Explicit monitor switch** (via keybind: focus_monitor_left/right):
- Uses wrap_monitor_index() to cycle through monitors
- Calls focus_or_fallback() on new monitor to restore appropriate focus
- Updates focused_monitor_ to new monitor
- Calls update_ewmh_current_desktop() to update EWMH state
- Warps cursor to center of new monitor if warp_cursor_on_monitor_change configured
- Early return if only 1 monitor exists

**Automatic monitor switch** (via focus or window movement):
- Focusing window on different monitor: Implicitly changes focused_monitor_, window becomes focused
- Moving focused window to different monitor: Updates focused_monitor_, window remains focused
- Does NOT warp cursor (warping only for explicit switch)
- Moving non-focused window to different monitor: Does NOT change focus or focused_monitor_

**Monitor Index Cycling** (wrap_monitor_index):
- Wraps monitor indices to stay within valid range
- For positive direction: if idx >= monitors_.size(), wraps to 0
- For negative direction: if idx < 0, wraps to monitors_.size() - 1
- Returns clamped index that is always valid (or 0 if no monitors exist)

**Monitor Switching via Pointer** (update_focused_monitor_at_point):
- Updates focused_monitor_ to the monitor containing the pointer point
- Called on: EnterNotify on root window, MotionNotify crossing monitor boundary, ButtonPress on any window
- Does NOT clear focus when entering root window
- Enables seamless monitor crossing without focus disruption

### Move Window to Monitor (move_to_monitor_left/right)

**For floating windows**:
- Repositions to center of target monitor's working area using floating::place_floating()
- Updates Client.monitor/workspace and FloatingWindow.geometry
- Updates _NET_WM_DESKTOP property
- Updates floating visibility on both source and target monitors
- Moves focused_monitor_ to target and calls focus_floating_window()
- Warps cursor if enabled

**For tiled windows**:
- Removes from source workspace.windows
- Updates source workspace.focused_window to last remaining window (or XCB_NONE if empty)
- Adds to target monitor's current workspace.windows
- Sets target workspace.focused_window to moved window
- Rearranges both source and target monitors
- Updates focused_monitor_ to target and calls focus_window()
- Warps cursor if enabled

### Floating Window Monitor Auto-Assignment

**Function**: update_floating_monitor_for_geometry(window)

**When called**:
- After handle_configure_request() for floating windows
- During drag operations (update_drag())
- Any time floating window geometry changes

**Behavior**:
- Calculates window center point: (x + width/2, y + height/2)
- Determines which monitor contains the center (monitor_index_at_point())
- If center moved to different monitor:
  - Updates Client.monitor to new monitor
  - Updates Client.workspace to new monitor's current workspace
  - Updates _NET_WM_DESKTOP property
  - If window IS active window: Updates focused_monitor_, calls update_ewmh_current_desktop()
- Does NOT:
  - Call focus_or_fallback()
  - Update focused_monitor_ (for non-active windows)
  - Restack the window
  - Change focus state
- If center not on any monitor (off all screens): No change to monitor assignment
- This is intentional - the window simply "belongs" to a different monitor after moving

---

## Interaction Modes

LWM has three global interaction modes that affect event processing:

### NORMAL Mode

Default interaction mode (drag_state_.active = false, showing_desktop_ = false).

**Behavior:**
- All events processed normally
- EnterNotify: Focus-follows-mouse applies
- MotionNotify: Re-establish focus if lost
- ButtonPress: Focus window, begin drag

### DRAG Mode

Drag state active (drag_state_.active = true).

**Entry conditions:**
- begin_tiled_drag() called on tiled window
- begin_drag() called on floating window
- Both functions reject fullscreen windows and showing_desktop mode

**Behavior:**
- Ignores EnterNotify events (focus-follows-mouse disabled)
- Ignores MotionNotify events (except for drag updates via update_drag())
- ButtonRelease calls end_drag()
- KeyPress events ARE processed: keybinds can execute during drag (e.g., toggle_fullscreen, kill_window)

**Exit conditions:**
- ButtonRelease → end_drag()
- Window destroyed during drag → end_drag() returns early (monitors check fails)
- All monitors disconnected → end_drag() returns early

**Edge cases:**
- If window is destroyed during drag: drag_state_ is reset but window geometry is not restored
- If all monitors disconnected: pointer is ungrabbed but window remains at last position
- No error logging for these cases (intentional no-op)

### SHOWING_DESKTOP Mode

Desktop mode enabled (showing_desktop_ = true).

**Entry condition:**
- _NET_SHOWING_DESKTOP ClientMessage with value=1

**Behavior:**
- LWM calls hide_window() for all non-sticky windows
- hide_window() returns early for sticky windows, so they remain visible (physically on-screen but not focusable if iconic)
- Clears focus
- rearrange_monitor() returns early (no layout calculations)
- Cannot start tiled drag operations

**Iconic sticky windows during showing_desktop**: Iconic sticky windows (iconic=true, hidden=false) remain physically visible (on-screen position) during showing_desktop mode but cannot receive focus. They are not focusable because they are iconic, not because showing_desktop mode hides them.

**Exit condition:**
- _NET_SHOWING_DESKTOP ClientMessage with value=0
- Shows all hidden windows
- Calls rearrange_monitor() to restore layout
- Calls focus_or_fallback() to restore focus

---

## Geometry Management

### Geometry Application Order

Critical sequence for preventing "flash" artifacts during window state changes:

1. Apply geometry-affecting states (fullscreen, maximized)
2. Configure geometry
3. Map window (xcb_map_window - always mapped)
4. Apply non-geometry states (above, below, skip_*)
5. If not visible: hide_window() (move off-screen)

### Size Hints

**Tiled windows**: Size hints ignored for geometry calculations
- Size hints are NOT used for geometry (window parameter unused in apply_size_hints, explicitly cast to void)
- WM controls geometry completely
- Applications must handle smaller sizes (scrolling, truncating, adapting)
- Matches other tiling WMs (DWM, i3, bspwm)
- Only clamp to minimum 1 pixel to prevent zero-size
- Tiled windows never have zero dimensions due to layout algorithm
- **Note**: When WM_NORMAL_HINTS change on tiled windows, WM triggers rearrange_monitor() to reaffirm its authority over window placement (design choice, not logical necessity of using hints)

**Floating windows**: Preferred size hints honored, constraints NOT enforced
- Position hints (P_POSITION, US_POSITION) honored for initial placement
- Preferred size (P_SIZE, US_SIZE) honored for initial geometry
- min_width/min_height NOT enforced
- max_width/max_height NOT enforced
- Only clamp to minimum 1 pixel to prevent zero-size
- Zero-sized windows (initial mapping only) fall back to 300x200 default
- Client may resize to 0x0 later (clamped to minimum 1 pixel)

**Size Hints on Tiled Windows During Changes**:
- When WM_NORMAL_HINTS change on tiled windows, trigger rearrange_monitor()
- Even though size hints are ignored, WM must reaffirm its control
- Applications may request geometry changes; WM reapplies its geometry

### Synthetic ConfigureNotify Generation

**Function**: `send_configure_notify(window)`

**Purpose**: Inform clients of their geometry after WM-initiated changes

**Implementation**:
- Queries current window geometry from X server
- Constructs synthetic ConfigureNotify event with:
  - event_type = ConfigureNotify
  - synthetic = true
  - geometry from WM
- Sends to client via xcb_send_event

**When called**:
- After layout_.arrange() to inform tiled windows of their geometry
- After fullscreen transition to inform window of fullscreen geometry
- After floating geometry changes to inform floating window of new geometry
- After apply_fullscreen_if_needed() when restoring fullscreen geometry

**Why synthetic**: Required by ICCCM and EWMH compliance; clients (especially Electron/Chrome apps) need to know their geometry immediately after WM changes it

---

## Layout Algorithm

### Master-Stack Tiling (layout.cpp)

**Configuration**
- `padding` - Gap around all windows
- `border_width` - Window border thickness

**Layout Cases**

| Windows | Layout |
|---------|--------|
| 0 | Empty |
| 1 | Single window fills usable area |
| 2 | Two windows side-by-side, equal width of available space |
| 3+ | Master on left (50%), stack on right (50%) |

**Master-Stack Calculation**

Note: Borders are drawn outside client area in X11, so layout calculations account for `border_width`.

```
working_area = monitor.geometry - struts
total_borders = 4 * border
slot_width = (working_area.width - 3*padding - total_borders) / 2

Master:
  x = working_area.x + padding + border
  y = working_area.y + padding + border
  width = slot_width
  height = working_area.height - 2*padding - 2*border

Stack (N windows):
  total_v_borders = N * 2 * border
  stack_avail_height = working_area.height - (N+1)*padding - total_v_borders
  stack_slot_height = stack_avail_height / N
  x = working_area.x + slot_width + 2*padding + border
  y = working_area.y + padding + border + i * (stack_slot_height + border + padding + border)
  width = slot_width
  height = stack_slot_height - border
```

**Note**: The Y position accumulates `stack_slot_height + border + padding + border` for each window, not just `i * stack_slot_height`. This correctly accounts for borders and padding between stacked windows.

**Minimum Dimensions**
- `MIN_DIM = 50` pixels enforced as lower bound for available space calculations

---

## Floating Windows

### Floating Window Management

**manage_floating_window()**
1. Determine placement:
   - Position hints from ICCCM WM_NORMAL_HINTS
   - Centered on parent for transients
   - Centered on monitor otherwise
2. Create FloatingWindow record
3. Create Client record (kind = Floating)
4. Set WM_STATE (Normal/Iconic)
5. Apply geometry states (fullscreen, maximized)
6. xcb_map_window() (always mapped)
7. If not visible: hide_window() (move off-screen)
8. Apply non-geometry states (above, below, skip_*)
9. Focus if appropriate (respects suppress_focus_ flag)

### Floating Visibility

```
is_floating_visible(window) =
    NOT client.hidden
    AND NOT showing_desktop
    AND NOT iconic
    AND (sticky OR workspace == current_workspace)
```

**Note**: This is the conceptual visibility condition. In code, update_floating_visibility() explicitly sets client.hidden based on this formula and applies geometry. The function checks showing_desktop separately and returns early if true.

**Floating Window Workspace Tracking**:
- Floating windows are tracked globally in `floating_windows_` vector (NOT per-workspace)
- Each floating window has Client.monitor and Client.workspace fields
- Visibility determined by workspace assignment (not by membership in Workspace::windows)

### Floating Geometry

- **Client.floating_geometry** is authoritative (persistent state)
- **FloatingWindow.geometry** is runtime state (transient, for layout calculations)
- These are always updated together via apply_floating_geometry(), which:
  1. Reads from Client.floating_geometry (accounting for fullscreen/maximized overrides)
  2. Updates FloatingWindow.geometry
  3. Configures the X window to match

### Floating Restack

- MRU ordering in floating_windows_ vector
- Promoted to end when focused
- _NET_CLIENT_LIST_STACKING reflects MRU order

---

## Drag Operations

### Drag State Machine (wm_drag.cpp)

```
                    ┌─────────────────────┐
                    │   Entry Conditions   │
                    └──────────┬──────────┘
                               │
                    ┌──────────▼──────────┐
                    │   DRAG ACTIVE       │
                    │   drag_state_.active│
                    │   = true           │
                    └──────────┬──────────┘
                               │
          ┌──────────────────────┼──────────────────────┐
          │                      │                      │
  ┌───────▼───────┐   ┌──────▼──────┐   ┌──────▼──────┐
  │ TILED DRAG     │   │FLOATING MOVE │   │FLOATING RESIZE│
  │ (reorder mode)  │   │              │   │              │
  └───────┬───────┘   └──────┬──────┘   └──────┬──────┘
          │                     │                     │
          │ MotionNotify       │ MotionNotify        │ MotionNotify
          │ updates window     │ updates window     │ updates window
          │ visual position   │ geometry           │ size
          │ (no layout)     │                     │
          │                     │                     │
          └─────────────────────┴─────────────────────┘
                               │
                    ┌──────────▼──────────┐
                    │   Exit Conditions   │
                    │   - ButtonRelease  │
                    │   - Window destroy │
                    │   - All monitors  │
                    │     disconnected    │
                    └──────────┬──────────┘
                               │
                    ┌──────────▼──────────┐
                    │   NORMAL MODE       │
                    │   (drag_state_    │
                    │   .active = false)  │
                    └─────────────────────┘
```

**Drag Entry Conditions** (begin_drag / begin_tiled_drag):
├─ NOT fullscreen window (is_client_fullscreen returns true)
├─ NOT showing_desktop mode (for tiled drag only)
├─ NOT floating window (for tiled drag only - has FloatingWindow record)
├─ Window in workspace (for tiled drag only - monitor_containing_window returns valid monitor)
└─ monitors_ is not empty

If any condition fails → Intentional no-op (returns immediately)

```
[ButtonRelease] OR [_NET_WM_MOVERESIZE direction=11 (cancel)]
    ↓
end_drag()
    ├─ If tiled:
    │  ├─ Determine target monitor from pointer
    │  ├─ If target workspace empty → Insert at position 0
    │  ├─ Else → Insert at nearest slot (drop_target_index)
    │  ├─ Rearrange monitors
    │  └─ Focus moved window
    └─ Ungrab pointer
```

**Intentional No-Op Conditions** (end_drag()):
- Source monitor or workspace lookup fails (window state corrupted)
- Window removed from source workspace during drag (window already removed)
- Client has been unmanaged during drag
- monitors_.empty() (all monitors disconnected)

**Drag Side Effects** (floating windows crossing monitor boundary):
- update_floating_monitor_for_geometry() updates Client.monitor and Client.workspace
- Updates focused_monitor_ to new monitor
- Calls update_ewmh_current_desktop()
- Does NOT call focus_or_fallback() (no automatic focus restoration)

**Tiled window drag**: Window follows cursor visually (temporary geometry), tiling layout NOT recalculated until drop
- Drop target: nearest slot center (Euclidean distance)
- Insertion position: layout_policy::drop_target_index()
- Empty workspace target: insertion defaults to position 0 (beginning)
- Same workspace drop: reorders within current workspace
- Cross-workspace drop: moves window to target workspace, updates Client.monitor and Client.workspace

**Drag Edge Cases**:
- If window is destroyed or unmapped during drag, end_drag() aborts silently:
   - drag_state_.active, drag_state_.tiled, drag_state_.resizing are set to false
   - drag_state_.window = XCB_NONE
   - xcb_ungrab_pointer() is called to release pointer grab
   - No attempt to restore window geometry or update layout
   - Window remains at last drag position (or is gone if destroyed)
- If all monitors disconnect during drag (monitors_.empty() becomes true):
   - Drag operation is aborted (end_drag() returns early)
   - drag_state_.active is set to false
   - Pointer is ungrabbed
   - Window remains at last drag position
   - No error is logged (intentional no-op)

### Tiled Window Drag (Reorder Mode)

- Window follows cursor visually (temporary geometry)
- Tiling layout NOT recalculated until drop
- Drop target: nearest slot center (Euclidean distance)
- Insertion position: `layout_policy::drop_target_index()`
- Empty workspace target: If target workspace has no windows, insertion defaults to position 0 (beginning)

### Floating Window Drag

**Move**: Update x/y, apply within working area

**Resize**:
- Update width/height with size hints
- Constrain to working area
- Apply geometry immediately

---

## EWMH Protocol

### Root Window Properties

**Note**: The "active monitor" referenced in these properties is the monitor stored in `focused_monitor_`.

| Property | Value | Update Timing |
|----------|-------|---------------|
| _NET_SUPPORTED | List of all supported atoms | Startup |
| _NET_SUPPORTING_WM_CHECK | WM's own window | Startup |
| _NET_WM_NAME | "LWM" | Startup |
| _NET_NUMBER_OF_DESKTOPS | monitors × workspaces_per_monitor | Monitor change |
| _NET_DESKTOP_NAMES | Null-separated workspace names | Monitor change |
| _NET_CURRENT_DESKTOP | Active monitor's current workspace | Workspace switch |
| _NET_ACTIVE_WINDOW | Currently focused window | Focus change |
| _NET_CLIENT_LIST | Managed windows (map order) | Manage/unmanage |
| _NET_CLIENT_LIST_STACKING | Stacking order | Focus/restack |
| _NET_WM_DESKTOP | Per-window desktop | Manage/move/sticky |
| _NET_DESKTOP_VIEWPORT | Monitor origins per desktop | Monitor change |
| _NET_DESKTOP_GEOMETRY | Total desktop dimensions | Monitor change |
| _NET_WORKAREA | Usable area minus struts | Strut change |
| _NET_FRAME_EXTENTS | (0,0,0,0) - no decorations | Query |
| _NET_WM_ALLOWED_ACTIONS | Per-window supported operations | Manage |
| _NET_SHOWING_DESKTOP | Desktop mode toggle | Toggle |

### Window Types

Classification priority:

1. **DESKTOP** → Kind::Desktop (below all, not focusable, visible on all workspaces, NOT hidden during workspace switch)
2. **DOCK** → Kind::Dock (reserves struts, not focusable)
3. **TOOLBAR/MENU/SPLASH** → Kind::Floating (skip_taskbar, skip_pager)
4. **UTILITY** → Kind::Floating (skip_taskbar, skip_pager, above)
5. **DIALOG** → Kind::Floating
6. **DROPDOWN_MENU/POPUP_MENU/TOOLTIP/NOTIFICATION/COMBO/DND** → Kind::Popup (mapped directly, not managed)
7. **NORMAL** → Kind::Tiled (or Floating if transient/rule)

### Client Message Handlers

| Message | Behavior |
|---------|----------|
| _NET_ACTIVE_WINDOW | Focus window, switch desktop if needed. Focus stealing prevention via user_time (source=1) or allow (source=2). If timestamp == 0, always allowed |
| _NET_CLOSE_WINDOW | Send WM_DELETE_WINDOW or force kill after timeout |
| _NET_WM_STATE | ADD/REMOVE/TOGGLE state atoms (data[1], data[2]) |
| _NET_CURRENT_DESKTOP | Switch to desktop (monitor/workspace). If invalid monitor index, silently ignored |
| _NET_WM_DESKTOP | Move window to desktop (0xFFFFFFFF = sticky). When 0xFFFFFFFF is received, the window's sticky flag is set via set_window_sticky(true). When a specific desktop is received, sticky flag is cleared via set_window_sticky(false) and window moves to that desktop. |
| _NET_FULLSCREEN_MONITORS | Store monitor bounds, apply if fullscreen |
| _NET_REQUEST_FRAME_EXTENTS | Return (0,0,0,0) |
| _NET_MOVERESIZE_WINDOW | Programmatic move/resize (floating only). Flags: bits 8-11=gravity, 12=x, 13=y, 14=width, 15=height |
| _NET_MOVERESIZE | Interactive move/resize (floating only). Direction: 8=move, 11=cancel, 0-7=resize edges. Cancel (11) calls end_drag() directly |
| _NET_RESTACK_WINDOW | Restack relative to sibling (above/below) |
| _NET_SHOWING_DESKTOP | Toggle desktop mode (hide all/restore using hide_window) |
| WM_PROTOCOLS:_NET_WM_PING | Response → cancel pending kill (window alive). May come from user_time_window (data[2] = ping origin) |
| WM_PROTOCOLS:WM_DELETE_WINDOW | Graceful close request |
| WM_PROTOCOLS:WM_TAKE_FOCUS | Used for input=False windows |
| WM_CHANGE_STATE | Iconify/Deiconify (IconicState/NormalState) |

 ### Ping-Kill Protocol

```
kill_window()
├─ Check for WM_DELETE_WINDOW support
├─ If supported:
│  ├─ Send WM_DELETE_WINDOW client message (graceful close)
│  ├─ Send _NET_WM_PING
│  ├─ Schedule pending kill (5 second timeout)
│  ├─ If ping response → cancel pending kill (window alive)
│  └─ If timeout → xcb_kill_client() force kill
└─ If NOT supported:
   └─ Force kill immediately (no graceful close)

handle_timeouts()
├─ Clean up expired pending_pings_ entries (remove old entries)
├─ Force-kill windows with expired pending_kills_
└─ xcb_kill_client() for unresponsive windows
```

**Constants**:
- PING_TIMEOUT = 5 seconds
- KILL_TIMEOUT = 5 seconds

**Note**: See [Focus System → Focus Stealing Prevention](#focus-stealing-prevention) for detailed user_time_window handling for focus stealing prevention. _NET_WM_PING responses may also come from user_time_window (data[2] = ping origin).

  ### Sync Request (Fire-and-Forget)

- Sent before WM-initiated resizes
- Non-blocking: does NOT wait for client update
- Client::sync_value incremented
- Split 64-bit value into two 32-bit data fields for X11 protocol
- Prevents event loop blocking
- Implementation tries to wait for sync counter with 50ms timeout:
  - wait_for_sync_counter() attempts to read updated counter value
  - If client doesn't respond within 50ms, operation proceeds anyway (non-blocking fallback)
  - Compromise: most clients respond quickly, but hung clients don't block event loop

---

## ICCCM Compliance

### Selection & Ownership

- Acquire `WM_S0` selection on `WM_Sn` atom
- Fail if another WM already owns selection
- Broadcast `MANAGER` client message after acquiring
- Respond to `SelectionClear` by exiting
- Select `SubstructureRedirectMask` on root

### WM_STATE Management

| State | Value | When Set |
|-------|--------|-----------|
| Withdrawn | 0 | On unmanage_window() |
| Normal | 1 | On manage/map (non-iconic), deiconify_window() |
| Iconic | 3 | On iconify_window(), WM_HINTS.initial_state=Iconic |

**Critical**: WM_STATE NOT changed for workspace visibility or showing_desktop mode. Only iconification/deiconification changes WM_STATE (set to Normal or Iconic on management).

### Unmap Tracking

**Off-Screen Visibility Model**: See [Window State Machine → Off-Screen Visibility Architecture](#off-screen-visibility-architecture) for details on how LWM uses off-screen positioning instead of unmap/map for visibility control.

**UnmapNotify Handling**: With off-screen visibility, ANY UnmapNotify is treated as a client-initiated withdraw request → unmanage_window(). No counter tracking exists.

### Properties Read & Honored

| Property | Behavior |
|----------|----------|
| WM_NAME / _NET_WM_NAME | Window title |
| WM_CLASS | Window identification, rule matching |
| WM_CLIENT_MACHINE | Display/session management |
| WM_NORMAL_HINTS | Position (P_POSITION/US_POSITION) honored for initial placement. Size (P_SIZE/US_SIZE) honored for initial geometry. min/max NOT enforced. inc/aspect/gravity ignored. Tiled: triggers monitor rearrange on change (hints are ignored but rearrangement occurs) |
| WM_HINTS | input (focus eligibility), initial_state (iconic), urgency (demands_attention) |
| WM_TRANSIENT_FOR | Transient relationship, inherit workspace, auto skip_*, stack above parent |
| WM_PROTOCOLS | DELETE_WINDOW, TAKE_FOCUS, _NET_WM_PING, _NET_WM_SYNC_REQUEST |
| _NET_WM_USER_TIME | User time for focus stealing prevention. May be on user_time_window (indirect) |
 | _NET_WM_STATE_HIDDEN | Initial iconic state check (takes precedence over WM_HINTS.initial_state) |

  ### Properties Written

 | Property | Timing |
 |----------|--------|
 | WM_STATE | Manage, unmanage, iconify, deiconify |
 | ConfigureNotify (synthetic) | After layout, fullscreen, floating geometry changes. See [Geometry Management](#geometry-management) for details. |
 | _NET_WM_STATE | All state flag changes |
 | _NET_WM_STATE_FOCUSED | Focus change (set on focused window, cleared from previously focused window) |
 | _NET_WM_DESKTOP | Manage, move to workspace, sticky toggle, monitor assignment |
 | _NET_CLIENT_LIST | Manage, unmanage |
 | _NET_CLIENT_LIST_STACKING | Focus change, restack |
 | _NET_ACTIVE_WINDOW | Focus change |
 | _NET_WORKAREA | Strut change |
 | _NET_FULLSCREEN_MONITORS | Multi-monitor fullscreen |

**WM_PROTOCOLS Selection on Client Windows**:
- Event mask: XCB_EVENT_MASK_ENTER_WINDOW | XCB_EVENT_MASK_FOCUS_CHANGE | XCB_EVENT_MASK_PROPERTY_CHANGE
- Floating windows additionally select: XCB_EVENT_MASK_BUTTON_PRESS
- Note: STRUCTURE_NOTIFY is NOT selected on client windows
  - Selecting STRUCTURE_NOTIFY causes duplicate UnmapNotify events
  - Duplicate events would break off-screen visibility model (would incorrectly unmanage windows during workspace switches)

### Window Lifecycle Events

| Event | Handling |
|-------|-----------|
| MapRequest | If already managed: deiconify_window(). Else: Classify → manage/floating/dock/desktop/popup. Apply rules. Honor EWMH states |
| UnmapNotify | With off-screen visibility, treat as client-initiated withdraw → unmanage_window(). No counter check |
| DestroyNotify | Remove from all structures, restore focus if was active |
| ConfigureRequest | Tiled: synthetic ConfigureNotify. Floating: apply within hints. Fullscreen: fullscreen geometry |
| PropertyNotify | Update state, title, hints, sync counter, struts. Handle user_time_window indirection for _NET_WM_USER_TIME |

**See also**: Window State Machine → Window Lifecycle for detailed sequence diagrams

---

## Configuration

### Configuration Structure

**[appearance]** - Visual settings
- `padding` - Gap around all windows
- `border_width` - Window border thickness
- `border_color` - Active window border (hex)

**[focus]** - Focus behavior
- `warp_cursor_on_monitor_change` - Warp cursor to monitor center on explicit switch (bool)

**[programs]** - External programs
- `terminal` - Terminal emulator path
- `browser` - Web browser path
- `launcher` - Application launcher path

**[workspaces]** - Workspace configuration
- `count` - Number of workspaces per monitor
- `names` - Workspace names (auto-normalized)

**[autostart]** - Startup programs
- `commands` - Array of commands to execute on startup

**[[keybinds]]** - Keyboard shortcuts
- `mod` - Modifier key (super, super+shift, super+ctrl)
- `key` - Key to bind (1-0 keys support AZERTY and QWERTY)
- `action` - Action to execute
- `command` - Program path (for spawn action)
- `workspace` - Workspace number (for workspace actions)

**[[mousebinds]]** - Mouse bindings
- `mod` - Modifier key
- `button` - Mouse button (1=left, 3=right)
- `action` - drag_window or resize_floating

**[[rules]]** - Window classification rules
- `class` - WM_CLASS class name pattern (regex)
- `instance` - WM_CLASS instance name pattern (regex)
- `title` - Window title pattern (regex)
- `type` - EWMH type (normal/dialog/utility/toolbar/splash/menu)
- `transient` - Match only transients (bool)
- Actions (applied if criteria match):
    - `floating` - Force floating or tiled
    - `workspace` / `workspace_name` - Assign to workspace
    - `monitor` / `monitor_name` - Assign to monitor
    - `fullscreen` - Start fullscreen
    - `above` / `below` - Set stacking order
    - `sticky` - Visible on all workspaces
    - `skip_taskbar` / `skip_pager` - Exclude from UI
     - `geometry` - {x, y, width, height} for floating
     - `center` - Center floating window

### Window Rules Engine

**Matching** (AND logic)
- All specified criteria must match
- First match wins (stop after finding)
- Empty criteria matches all

**Criteria**
- `class` - WM_CLASS class name (regex)
- `instance` - WM_CLASS instance name (regex)
- `title` - Window title (regex)
- `type` - EWMH type (normal/dialog/utility/toolbar/splash/menu)
- `transient` - Match only transients (bool)

**Regex Compilation and Fallback**
- Patterns compiled to regex at startup
- Invalid patterns fall back to literal string matching
- Warning logged to stderr for invalid regex
- Ensures rules always work, even with invalid patterns

**Actions**
- `floating` - Force floating or tiled
- `workspace` / `workspace_name` - Assign workspace
- `monitor` / `monitor_name` - Assign monitor
- `fullscreen` - Start fullscreen
- `above` / `below` - Stacking order
- `sticky` - Visible on all workspaces
- `skip_taskbar` / `skip_pager` - Exclude from UI
- `geometry` - {x, y, width, height} for floating
- `center` - Center floating window

**Application Timing**: AFTER EWMH classification, BEFORE management. Cannot override DOCK, DESKTOP, or POPUP types (EWMH protocol protected).

**Window Rule Application Order**:
1. EWMH type classification (classify_window)
2. Initial _NET_WM_STATE read from window properties
3. Window rules matching and application (can override EWMH states except Dock/Desktop/Popup)
    - If target_mon >= monitors_.size(): Entire rule application is silently skipped
    - No state flags, geometry changes, or workspace/monitor reassignment applied
4. Geometry application (rule geometry takes precedence)
    - Rule geometry (if specified) → Applied BEFORE mapping
    - Otherwise → Placement logic (center on monitor or relative to parent)
    - Position hints honored for initial placement (P_POSITION, US_POSITION)
    - Preferred size hints honored for initial geometry (P_SIZE, US_SIZE)
5. Final state flag application (fullscreen, above, below, skip_*)
6. Window mapping (xcb_map_window)
7. Visibility control (hide_window if not visible)

**Geometry Precedence**:
1. Rule geometry (highest priority)
2. Fullscreen geometry (if fullscreen enabled)
3. Maximized geometry (if maximized enabled and not fullscreen)
4. Placement logic / hints (lowest priority)

**Note**: When a rule sets both `fullscreen=true` AND explicit `geometry={x,y,width,height}`, fullscreen geometry takes precedence and rule geometry is saved for restoration when fullscreen is disabled. The rule geometry only applies to non-fullscreen windows.

**Rule State Precedence**:
- Window rules CAN override initial _NET_WM_STATE (except for Dock/Desktop/Popup types)
- Rule states are applied after reading initial EWMH atoms
- Rule actions like `fullscreen`, `above`, `below` are applied AFTER initial state read
- Rule geometry (`geometry` or `center`) is applied BEFORE mapping

### State Flags Quick Reference

| Flag | Purpose | Triggers | Clears/Conflicts With |
|-------|---------|-----------|----------------------|
| hidden | Off-screen visibility control | Workspace switch, showing_desktop, iconify (sticky windows excluded) | N/A |
| fullscreen | Full screen mode | set_fullscreen(), _NET_WM_STATE | maximized (clears), above/below (clears) |
| iconic | Minimized state | iconify_window(), WM_HINTS.initial_state | None (may coexist with sticky) |
| sticky | Visible on all workspaces | set_window_sticky(), _NET_WM_DESKTOP=0xFFFFFFFF | None |
| above | Stacked above other windows | set_window_above(), modal (sets above) | below (mutually exclusive) |
| below | Stacked below other windows | set_window_below() | above (mutually exclusive) |
| maximized_horz/vert | Maximized to screen edges | set_window_maximized(), _NET_WM_STATE | None (but ignored when fullscreen) |
| shaded | Rolled up title bar only | set_window_shaded() | None |
| modal | Dialog behavior | set_window_modal() | None (sets above as side effect) |
| skip_taskbar | Exclude from taskbar | set_client_skip_taskbar(), EWMH classification | None |
| skip_pager | Exclude from pager | set_client_skip_pager(), EWMH classification | None |
| demands_attention | Urgent indication | set_client_demands_attention(), WM_HINTS | None |

### Supported Keybind Actions

| Action | Description | Parameters |
|---------|-------------|------------|
| spawn | Launch program | command |
| kill | Close window | None |
| switch_workspace | Switch workspace | workspace (0-9) |
| toggle_workspace | Switch to previous | None |
| move_to_workspace | Move window to workspace | workspace (0-9) |
| focus_monitor_left/right | Switch active monitor | None |
| move_to_monitor_left/right | Move window to monitor | None |
| toggle_fullscreen | Toggle fullscreen | None |
| focus_next/prev | Cycle focus | None |

**Modifiers**: super, super+shift, super+ctrl

### Workspace Normalization

- names only → count = names.size
- count only → names = "1".."count"
- names < count → pad with numeric names
- names > count → truncate
- Minimum count = 1

---

## Special Cases

### Focus Suppression During Initial Scan

**Purpose**: Prevent spurious focus changes during window scan on WM startup.

**Mechanism**:
- `suppress_focus_` flag is set to `true` during `scan_existing_windows()`
- Reset to `false` after scan completes
- `manage_floating_window()` checks `suppress_focus_` before focusing new windows
- Only allows focus if window is on focused monitor and visible workspace

### X Connection Error Detection

**Behavior**:
- Main loop checks `xcb_connection_has_error()` on each iteration
- If error detected: LOG_ERROR and initiate graceful shutdown
- Prevents hanging on X server disconnection

### Mousebind Validation

**Behavior**:
- Invalid mousebind configurations are silently filtered during initialization
- Filtered out: button <= 0, button > 255, empty action
- Config loading continues with valid mousebinds only







---

**⚠️ SUPERSEDED DOCUMENT**
This document is historical reference only. For current documentation, see:
- [DOCS_INDEX.md](DOCS_INDEX.md) - Complete documentation roadmap
- [IMPLEMENTATION.md](IMPLEMENTATION.md) - Architecture and data structures
- [STATE_MACHINE.md](STATE_MACHINE.md) - Window states and transitions
- [EVENT_HANDLING.md](EVENT_HANDLING.md) - Event handling specifications
